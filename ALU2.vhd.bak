LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.all;

ENTITY ALU2 IS
    PORT (
        clk, res : IN STD_LOGIC;
        A, B     : IN UNSIGNED(7 DOWNTO 0);
        opcode   : IN UNSIGNED(15 DOWNTO 0);
        Neg1, Neg2 : OUT STD_LOGIC;
        R1, R2   : OUT UNSIGNED(3 DOWNTO 0)
    );
END ALU2;

ARCHITECTURE ModifiedBehavior OF ALU2 IS
    SIGNAL Reg1, Reg2, Result : UNSIGNED(7 DOWNTO 0) := (OTHERS => '0');
BEGIN
   
    Reg1 <= A;
    Reg2 <= B;

    PROCESS (clk, res)
    BEGIN
        IF res = '1' THEN
            Result <= (OTHERS => '0');  -- Clear result
        ELSIF (clk'EVENT AND clk = '1') THEN
            -- Perform operations based on opcode
            CASE opcode IS
                WHEN "0000000000000001" => -- 1: Swap the lower and upper 4 bits of A
                    Result <= Reg1(3 DOWNTO 0) & Reg1(7 DOWNTO 4);
                WHEN "0000000000000010" => -- 2: Produce the result of ORing A and B
                    Result <= (Reg1 OR Reg2);
                WHEN "0000000000000100" => -- 3: Decrement B by 5
                    Result <= Reg2 - 5;
                WHEN "0000000000001000" => -- 4: Invert all bits of A
                    Result <= NOT(Reg1);
                WHEN "0000000000010000" => -- 5: Invert the bit-significance order of A
                    Result <= Reg1(0) & Reg1(1) & Reg1(2) & Reg1(3) & Reg1(4) & Reg1(5) & Reg1(6) & Reg1(7);
                WHEN "0000000000100000" => -- 6: Find the greater value of A and B and produce the result (Max(A, B))
                    IF Reg1 > Reg2 THEN
                        Result <= Reg1;
                    ELSE
                        Result <= Reg2;
                    END IF;
                WHEN "0000000001000000" => -- 7: Produce the difference between A and B
                    Result <= Reg1 - Reg2;
                WHEN "0000000010000000" => -- 8: Produce the result of XNORing A and B
                    Result <= (NOT(Reg1 XOR Reg2));
                WHEN OTHERS => 
                    Result <= (OTHERS => '0');
            END CASE;
        END IF;
    END PROCESS;

    
    R1 <= Result(3 DOWNTO 0);  -- lower 4 bits    
    R2 <= Result(7 DOWNTO 4);  -- upper 4 bits     
    Neg1 <= Result(7);         -- most significant bit    
    Neg2 <= Result(3);         -- 4th bit    
END ModifiedBehavior;
